/**
 * Problem of the optimal distribution of a stock on warehouses
 *
 * Derived from the basic code provided by René Natowicz (rene.natowicz@esiee.fr)
 * Code written in the framework of the IGI-2102 unit by Corentin Poupry (corentin.poupry@edu.esiee.fr) and Neo Jonas
 * (neo.jonas@edu.esiee.fr). All rights reserved.
 *
 * Created with Java 18
 **/

import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

public class OptimalWarehouse {
    /**
     * Maximum value of warehouses
     */
    public static final int WMAX = 50;

    /**
     * Maximum value of the stock
     */
    public static final int SMAX = 50;

    public static void main(String[] args) {
        var data = launch(10_000);
        Utils.export_data("optimal_warehouse", data);
    }

    /**
     * Launch the different strategies and review the results data
     * @param run_limit number of runs to make
     * @return the relative distances
     */
    static double[] launch(int run_limit) {
        // we use a thread local PRNG to ensure that there will be no unnecessary instantiation & allocations
        Random rand = ThreadLocalRandom.current();
        double[] data = new double[run_limit];

        long start_time = System.nanoTime();

        for (int run = 0; run < run_limit; run++) {
            System.out.printf("--- Run number #%d ---", run + 1);
            System.out.println();

            int stock = rand.nextInt(SMAX) + 1;
            System.out.printf("Stock: %d", stock);
            System.out.println();

            int warehouses = rand.nextInt(WMAX) + 1;
            System.out.printf("Number of warehouses: %d", warehouses);
            System.out.println();

            int[][] gains = generateGain(warehouses, stock);

            int[][] M = calculerMA(gains);
            var v = M[warehouses][stock];

            int g = glouton(gains, stock);

            Utils.print_result(g, v);

            data[run] = v == 0 ? 0 : (double) (v - g) / (double) v;
        }

        long elapsed_time = System.nanoTime() - start_time;

        System.out.println();
        System.out.printf("Elapsed time: %fms", (double) TimeUnit.NANOSECONDS.toMillis(elapsed_time));

        return data;
    }

    static int[][] calculerMA(int[][] G) {
        // G[0:n][0:S+1] de terme général
        // G[i][s] = gain d'une livraison d'un stock s à l'entrepôt i.

        // Calcule : M[0:n+1][0:S+1] de tg M[k][s] = m(k,s) et A = arg M.
        int n = G.length;
        int S = G[0].length - 1;
        int[][] M = new int[n + 1][S + 1];

        // base: m(0, s) = 0
        for (int s = 0; s < S + 1; s++)
            M[0][s] = 0;

        // cas général
        for (int k = 1; k < n + 1; k++) {
            for (int s = 0; s < S + 1; s++) {
                for (int sk = 0; sk < s + 1; sk++) {
                    int mks = G[k - 1][sk] + M[k - 1][s - sk];

                    if (mks > M[k][s]) M[k][s] = mks;
                }
            }
        }

        return M;
    }

    /**
     * Apply the greedy strategy
     * @param gains values of the gains for the warehouses
     * @param stock max stock usable
     * @return the resolution matrix
     */
    private static int glouton(int[][] gains, int stock) {
        int warehouses = gains.length;
        int[] stock_allocation = new int[warehouses];

        while (stock > 0) {
            int max = 0;
            int index = 0;

            // we find the most advantageous gain to work with by looking at the
            // difference between the stock with s+1 stock and s stock
            for (int i = 0; i < warehouses; i++) {
                int allocated = stock_allocation[i];
                int diff = gains[i][allocated + 1] - gains[i][allocated];

                if (diff > max) {
                    max = diff;
                    index = i;
                }
            }

            // a new stock is allocated to the most interesting unit
            stock_allocation[index] += 1;
            // our quota of stock is reduced by one
            stock -= 1;
        }

        int sum = 0;
        for (int i = 0; i < warehouses; i++) {
            int s = stock_allocation[i];
            sum += gains[i][s];
        }

        return sum;
    }

    /**
     * Generate random gain on warehouses according to the stock they have
     * This procedure is practically the same as for the optimal planning problem
     * @param warehouses number of warehouses
     * @param stock_max maximum number of stock
     * @return a 2D table representing the warehouses and the nested table, the gain that can
     * be expected with a stock corresponding to the index
     */
    static public int[][] generateGain(int warehouses, int stock_max) {
        Random rand = ThreadLocalRandom.current();

        // G[i][h] = g(i,h). Les estimations sont aléatoires, croissantes selon h.
        int[][] G = new int[warehouses][stock_max + 1];

        for (int i = 0; i < warehouses; i++) G[i][0] = 0;
        for (int i = 0; i < warehouses; i++)
            for (int h = 1; h <= stock_max; h++)
                G[i][h] = G[i][h - 1] + rand.nextInt(6);

        return G;
    }
}
